/* global module, process */

// Generated by CoffeeScript 1.8.0
(function(){
	var RedisDumper,
			__slice = [].slice,
			async = require('async'),
			Readable = require('stream').Readable,
			run = async.waterfall,
			redis = require('redis')
			;

	module.exports = function(params, callback){
		var dumper;
		if(params.port === null){
			params.port = 6379;
		}
		if(params.host === null){
			params.host = '127.0.0.1';
		}
		if(params.db === null){
			params.db = '0';
		}
		if(params.filter === null){
			params.filter = '*';
		}
		if(params.format === null){
			params.format = 'redis';
		}
		if(params.convert === null){
			params.convert = null;
		}
		dumper = new RedisDumper(params);
		return dumper.dump(params, function(){
			var params;
			params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			dumper.close();
			return callback.apply(null, params);
		});
	};

	RedisDumper = (function(){
		function RedisDumper(_arg){
			var host, port;
			port = _arg.port, host = _arg.host;
			this.db = _arg.client ? _arg.client : redis.createClient(port, host);
		}

		RedisDumper.prototype.close = function(){
			return this.db.end();
		};

		RedisDumper.prototype.escape = function(value){
			if(/^([a-zA-Z0-9_\:\-]+)$/.test("" + value)){
				return "" + value;
			}else{
				return "'" + ("" + value).split('\\').join('\\\\').split('\'').join('\\\'') + "'";
			}
		};

		RedisDumper.prototype.dump = function(_arg, callback){
			var e, filter = _arg.filter, numcmd = _arg.numcmd, db = _arg.db, count = _arg.count, format = _arg.format, convert = _arg.convert, pretty = _arg.pretty, keys = [], types = [], values, ttls;

			if(typeof convert === 'string'){
				try{
					convert = JSON.parse(convert);
				}catch(_error){
					e = _error;
					return callback(e);
				}
			}
			this.db.select(db);
			return run([
				(function(_this){
					return function(next){
						var k;
						try{
							if(!!convert){
								return next(null, (function(){
									var _results;
									_results = [];
									for(k in convert){
										_results.push(k);
									}
									return _results;
								})());
							}else{
								var scan = 0, data = [];
								async.doWhilst(
										function(next){
											_this.db.send_command("scan", [scan, "MATCH", filter, "COUNT", count], function(err, result)
											{
												if(err){
													console.log(err);
												}
												scan = +result[0];

												getType.apply(_this, [result[1], function(err, data){
														if(err)
															console.error(err);

														getValue.apply(_this, [data, function(err, data){
																if(err)
																	console.error(err);

																getTtl.apply(_this, [data, function(err, data){
																		if(err)
																			console.error(err);

																		getCommande.apply(_this, [data, function(err, data){
																				if(err)
																					console.error(err);


																			}]);
																	}]);
															}]);
													}]);

												setTimeout(next, 1000);
											});
										},
										function(){
											return scan > 0;
										},
										function(err){
											if(err){
												console.log(err);
											}
											return callback(null, data);
										}
								);
							}
						}catch(_error){
							e = _error;
							return next(e);
						}
					};
				})(this)
			], function(err, replay){
				return callback(err, replay);
			});

			function getType(ky, next){
				var k, key, multi, v, _j, _len1;
				try{
					keys = ky;
					if(!!convert){
						return next(null, (function(){
							var _results = [];
							for(k in convert){
								v = convert[k];
								_results.push(v.type);
							}
							return _results;
						})());
					}else{
						multi = this.db.batch();
						for(_j =0, _len1 = keys.length; _j < _len1; _j++){
							key = keys[_j];
							multi.type(key);
						}

						return multi.exec(next);
					}
				}catch(_error){
					e = _error;
					console.log(e);
					return next(e);
				}
			}

			function getValue(ty, next){
				var entry, type, multi, result, val, _ref;
				try{
					types = ty;
					if(!!convert){
						result = [];
						for(var i = 0, _l = types.length; i < _l; i++){
							type = types[i];
							switch(type){
								case 'string':
								case 'list':
								case 'set':
								case 'hash':
									result.push(convert[keys[i]].value);
									break;
								case 'zset':
									val = [];
									_ref = convert[keys[i]].value;
									for(var _k = 0, _l = _ref.length; _k < _l; _k++){
										entry = _ref[_k];
										val.push(entry[1]);
										val.push(entry[0]);
									}
									result.push(val);
									break;
							}
						}
						return next(null, result);
					}else{
						multi = this.db.batch();
						for(var i = 0, l = types.length; i < l; i++){
							type = types[i];
							switch(type){
								case 'string':
									multi.get(keys[i]);
									break;
								case 'list':
									multi.lrange(keys[i], 0, -1);
									break;
								case 'set':
									multi.smembers(keys[i]);
									break;
								case 'zset':
									multi.zrange(keys[i], 0, -1, 'withscores');
									break;
								case 'hash':
									multi.hgetall(keys[i]);
							}
						}

						return multi.exec(next);
					}
				}catch(_error){
					e = _error;
					return next(e);
				}
			}

			function getTtl(val, next){
				var key, multi, result, _j, i, k, _len1, _len2;
				try{
					values = val;
					if(!!convert){
						result = [];
						for(_j = 0, _len1 = keys.length; _j < _len1; _j++){
							key = keys[_j];
							if(!!convert[key].ttl){
								result.push("" + convert[key].ttl);
							}else{
								result.push("-1");
							}
						}
						return next(null, result);
					}
					else{
						multi = this.db.batch();
						for(i = k = 0, _len2 = keys.length; i < _len2; i++){
							key = keys[i];
							multi.ttl(key);
						}

						return multi.exec(next);
					}
				}
				catch(_error){
					e = _error;
					return next(e);
				}
			}

			function getCommande(tl, next){
				var commands, strcmd, i, item, j, json, k, key, len, ttl, type, v, value, _l, _len1, _len2, _len3, rs = Readable(), _len4, _len5, _m;
				rs._read = function(str){
					rs.push(str);
					rs.push(null);
				};
				rs.pipe(process.stdout);

				process.on('exit', function(){
					console.error('\n_read() called ' + (values.length) + ' times');
				});
				process.stdout.on('error', process.exit);

				try{
					ttls = tl;
					switch(format){
						case 'json' || 'raw':
							json = {};
							for(i = 0, _len1 = types.length; i < _len1; i++){
								type = types[i];
								key = keys[i];
								value = values[i];
								switch(type){
									case 'string':
										json[key] = {
											type: 'string',
											value: value
										};
										break;
									case 'list':
										json[key] = {
											type: 'list',
											value: value
										};
										break;
									case 'set':
										json[key] = {
											type: 'set',
											value: value.sort()
										};
										break;
									case 'zset':
										json[key] = {
											type: 'zset',
											value: (function(){
												var _len2, _results;
												_results = [];
												for(j = 0, _len2 = value.length; j < _len2; j += 2){
													item = value[j];
													_results.push([parseInt(value[j + 1], 10), value[j]]);
												}
												return _results;
											})()
										};
										break;
									case 'hash':
										json[key] = {
											type: 'hash',
											value: value
										};
								}
								ttl = parseInt(ttls[i], 10);
								if(!isNaN(ttl) && ttl !== -1){
									json[key].ttl = ttl;
								}
							}
							if(format === 'json'){
								if(pretty){
									return callback(null, JSON.stringify(json, null, 4));
								}else{
									return callback(null, JSON.stringify(json));
								}
							}else{
								return callback(null, json);

							}
							break;
						default:
							commands = "";

							for(i = 0, _len2 = types.length; i < _len2; i++){
								type = types[i];
								key = keys[i];
								value = values[i];
								switch(type){
									case 'string':
										commands +=("SET " + (this.escape(key)) + " " + (this.escape(value)))+"\n";
										break;
									case 'list':
										strcmd = "";
										commands +=("DEL " + (this.escape(key)))+"\n";
										for(_l = 0, _len3 = value.length; _l < _len3; _l++){
											item = value[_l];
											strcmd += " " + (this.escape(item));
										}
										commands +=("RPUSH " + (this.escape(key)) + strcmd)+"\n";
										break;
									case 'set':
										strcmd = "";
										commands +=("DEL " + (this.escape(key)))+"\n";
										if(value.length !== 0){
											for(_m = 0, _len4 = value.length; _m < _len4; _m++){
												item = value[_m];
												strcmd += " " + this.escape(item);
											}
											commands +=("SADD " + (this.escape(key)) + strcmd)+"\n";
										}
										break;
									case 'zset':
										strcmd = "";
										commands +=("DEL " + (this.escape(key)))+"\n";
										if(value.length !== 0){
											for(j = 0, _len5 = value.length; j < _len5; j += 2){
												item = value[j];
												strcmd += " " + (this.escape(value[j + 1])) + " " + (this.escape(value[j]));
											}
											commands +=("ZADD " + (this.escape(key)) + strcmd)+"\n";
										}
										break;
									case 'hash':
										strcmd = "";
										commands +=("DEL " + (this.escape(key)))+"\n";
										len = 0;
										for(k in value){
											len++;
										}
										if(len !== 0){
											strcmd = "";
											for(k in value){
												v = value[k];
												strcmd += " " + (this.escape(k)) + " " + (this.escape(v));
											}
											commands +=("HMSET " + (this.escape(key)) + strcmd)+"\n";
										}
								}
								ttl = parseInt(ttls[i], 10);
								if(!isNaN(ttl) && ttl !== -1){
									commands +=("EXPIRE  " + (this.escape(key)) + " " + ttl)+"\n";
								}
							}

							rs._read(commands);

							return next();;
					}
				}catch(_error){
					e = _error;
					return next(e);
				}
			}
		};

		return RedisDumper;

	})();

}).call(this);
