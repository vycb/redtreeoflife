/* global module, process */

// Generated by CoffeeScript 1.8.0
(function(){
	var RedisDumper,
			__slice = [].slice,
			async = require('async'),
			Readable = require('stream').Readable,
			run = async.waterfall,
			redis = require('redis')
			;

	module.exports = function(params, callback){
		var dumper;
		if(params.port === null){
			params.port = 6379;
		}
		if(params.host === null){
			params.host = '127.0.0.1';
		}
		if(params.db === null){
			params.db = '0';
		}
		if(params.filter === null){
			params.filter = '*';
		}
		if(params.format === null){
			params.format = 'redis';
		}
		if(params.convert === null){
			params.convert = null;
		}
		dumper = new RedisDumper(params);

		return dumper.dump(params, function(){
			var params;
			params = 1 <= arguments.length?__slice.call(arguments, 0):[];
			dumper.close();
			return callback.apply(null, params);
		});
	};

	RedisDumper = (function(){
		function RedisDumper(_arg){
			var host, port;
			port = _arg.port, host = _arg.host;
			this.db = _arg.client ? _arg.client : redis.createClient(port, host);
		}

		RedisDumper.prototype.close = function(){
			return this.db.end();
		};

		String.prototype.nonl = function(){
			return this.replace(/(\r\n|\n|\r)/gm,"");
		};

		function escape1q(value){
			if(/^([a-zA-Z0-9_\:\-]+)$/.test("" + value)){
				return "" + value;
			}else{
				return "'" + ("" + value).split('\\').join('\\\\').split('\'').join('\\\'') + "'";
			}
		}

		function escape2q(value){
			if(/^([a-zA-Z0-9_\:\-]+)$/.test("" + value)){
				return ("" + value).nonl();
			}else{
				return ('"' + ("" + value).split('\\').join('\\\\').split('\"').join('\\\"') + '"').nonl();
			}
		}

		RedisDumper.prototype.escape = escape2q;

		RedisDumper.prototype.dump = function(_arg, callback){
			var e, filter = _arg.filter, numcmd = _arg.numcmd, db = _arg.db, count = _arg.count, format = _arg.format, convert = _arg.convert, pretty = _arg.pretty, keys = [], types = [], values, ttls;

			if(typeof convert === 'string'){
				try{
					convert = JSON.parse(convert);
				}catch(_error){
					e = _error;
					return callback(e);
				}
			}
			this.db.select(db);
			return run([
				(function(_this){
					return function(next){
						var k;
						try{
							if(!!convert){
								return next(null, (function(){
									var _results;
									_results = [];
									for(k in convert){
										_results.push(k);
									}
									return _results;
								})());
							}else{
								var scan = 0, data = [];
								async.doWhilst(
										function(next){
											_this.db.send_command("scan", [scan, "MATCH", filter, "COUNT", count], function(err, result)
											{
												if(err){
													console.log(err);
												}
												scan = +result[0];

												getType.apply(_this, [result[1], function(err, data){
														if(err)
															console.error(err);

														getValue.apply(_this, [data, function(err, data){
																if(err)
																	console.error(err);

																getTtl.apply(_this, [data, function(err, data){
																		if(err)
																			console.error(err);

																		getCommande.apply(_this, [data, function(err, data){
																				if(err)
																					console.error(err);


																			}]);
																	}]);
															}]);
													}]);

												setTimeout(next, 1000);
											});
										},
										function(){
											return scan > 0;
										},
										function(err){
											if(err){
												console.log(err);
											}
											return callback(null, data);
										}
								);
							}
						}catch(_error){
							e = _error;
							return next(e);
						}
					};
				})(this)
			], function(err, replay){
				return callback(err, replay);
			});

			function getType(ky, cb){
				var k, key, batch, v, _j, _len1;
				try{
					keys = ky;
					if(!!convert){
						return cb(null, (function(){
							var _results = [];
							for(k in convert){
								v = convert[k];
								_results.push(v.type);
							}
							return _results;
						})());
					}else{
						batch = this.db.batch();
						for(_j = 0, _len1 = keys.length; _j < _len1; _j++){
							key = keys[_j];
							batch.type(key);
						}

						return batch.exec(cb);
					}
				}catch(_error){
					e = _error;
					console.log(e);
					return cb(e);
				}
			}

			function getValue(ty, cb){
				var entry, type, batch, result, val, _ref;
				types = ty;
				if(!!convert){
					result = [];
					for(var i = 0, _l = types.length; i < _l; i++){
						type = types[i];
						switch(type){
							case 'string':
							case 'list':
							case 'set':
							case 'hash':
								result.push(convert[keys[i]].value);
								break;
							case 'zset':
								val = [];
								_ref = convert[keys[i]].value;
								for(var _k = 0, _l = _ref.length; _k < _l; _k++){
									entry = _ref[_k];
									val.push(entry[1]);
									val.push(entry[0]);
								}
								result.push(val);
								break;
						}
					}
					return cb(null, result);
				}else{
					batch = this.db.batch();
					for(var i = 0, le = types.length; i < le; i++){
						type = types[i];
						switch(type){
							case 'string':
								batch.get(keys[i]);
								break;
							case 'list':
								batch.lrange(keys[i], 0, -1);
								break;
							case 'set':
								batch.smembers(keys[i]);
								break;
							case 'zset':
								batch.zrange(keys[i], 0, -1, 'withscores');
								break;
							case 'hash':
								batch.hgetall(keys[i]);
						}
					}

					return batch.exec(cb);
				}
			}

			function getTtl(val, cb){
				var key, batch, result, _j, i, k, _len1, _len2;
				values = val;
				if(!!convert){
					result = [];
					for(_j = 0, _len1 = keys.length; _j < _len1; _j++){
						key = keys[_j];
						if(!!convert[key].ttl){
							result.push("" + convert[key].ttl);
						}else{
							result.push("-1");
						}
					}
					return cb(null, result);
				}
				else{
					batch = this.db.batch();
					for(i = k = 0, _len2 = keys.length; i < _len2; i++){
						key = keys[i];
						batch.ttl(key);
					}

					return batch.exec(cb);
				}
			}

			function getCommande(tl, cb){
				var commands, strcmd, item, json, key, ttl, type, value, rs = Readable();

				rs._read = function(str){
					rs.push(str);
					rs.push(null);
				};
				rs.pipe(process.stdout);

				ttls = tl;
				switch(format){
					case 'json':
					case 'raw':
						json = {};
						for(var ig = 0, lg = types.length; ig < lg; ig++){
							type = types[ig];
							key = keys[ig];
							value = values[ig];
							switch(type){
								case 'string':
									json[key] = {
										type: 'string',
										value: value
									};
									break;
								case 'list':
									json[key] = {
										type: 'list',
										value: value
									};
									break;
								case 'set':
									json[key] = {
										type: 'set',
										value: value.sort()
									};
									break;
								case 'zset':
									json[key] = {
										type: 'zset',
										value: (function(){
											var _results = [];
											for(var j = 0, l = value.length; j < l; j+= 2){
												item = value[j];
												_results.push([parseInt(value[j + 1], 10), value[j]]);
											}
											return _results;
										})()
									};
									break;
								case 'hash':
									json[key] = {
										type: 'hash',
										value: value
									};
							}
							ttl = parseInt(ttls[ig], 10);
							if(!isNaN(ttl) && ttl !== -1){
								json[key].ttl = ttl;
							}
						}
						if(format === 'json'){
							if(pretty){
								return callback(null, JSON.stringify(json, null, 4));
							}else{
								return callback(null, JSON.stringify(json));
							}
						}else{
							return callback(null, json);
						}
						break;

					default:
						commands = "";
						for(var ig = 0, lg = types.length; ig < lg; ig++){
							type = types[ig];
							key = keys[ig];
							value = values[ig];
							switch(type){
								case 'string':
									commands += ("SET " + (this.escape(key)) + " " + (this.escape(value))) + "\n";
									break;
								case 'list':
									strcmd = "";
									commands += ("DEL " + (this.escape(key))) + "\n";
									for(var i = 0, l = value.length; i < l; i++){
										item = value[i];
										strcmd += " " + (this.escape(item));
									}
									commands += ("RPUSH " + (this.escape(key)) + strcmd) + "\n";
									break;
								case 'set':
									strcmd = "";
									commands += ("DEL " + (this.escape(key))) + "\n";
									if(value.length > 0){
										for(var i = 0, l = value.length; i < l; i++){
											item = value[i];
											strcmd += " " + this.escape(item);
										}
										commands += ("SADD " + (this.escape(key)) + strcmd) + "\n";
									}
									break;
								case 'zset':
									strcmd = "";
									commands += ("DEL " + (this.escape(key))) + "\n";
									if(value.length > 0){
										for(var i = 0, le = value.length; i < le; i += 2){
											item = value[i];
											strcmd += " " + (this.escape(value[i + 1])) + " " + (this.escape(value[i]));
										}
										commands += ("ZADD " + (this.escape(key)) + strcmd) + "\n";
									}
									break;
								case 'hash':
									commands += ("DEL " + (this.escape(key))) + "\n";
									if(Object.keys(value).length > 0){
										strcmd = "";
										for(var k in value){
											var v = value[k];
											strcmd += " " + (this.escape(k)) + " " + (this.escape(v));
										}
										commands += ("HMSET " + this.escape(key) + strcmd) + "\n";
									}
							}
							ttl = parseInt(ttls[ig], 10);
							if(!isNaN(ttl) && ttl !== -1){
								commands += ("EXPIRE  " + (this.escape(key)) + " " + ttl) + "\n";
							}
						}

						rs._read(commands);

						return cb();
				}
			}
		};

		return RedisDumper;

	})();

}).call(this);
