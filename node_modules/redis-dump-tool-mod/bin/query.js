
/* global process, require, QueryRedis, callback, module */

var Redis = require('redis'),
	async = require('async')
	;
var QueryRedis = module.exports = function(params){
	'use strict';

	var client;

	/**
	 * @return {String} version of library.
	 */
	this.getVersion = function(){
		return '0.2.1';
	};

	/**
	 * @return {Object} redis client.
	 */
	this.getClient = function(){
		return client || params.client;
	};

	this.setClient = function(cl){
		client = cl;
	};

	/**
	 * @return {Object} initialize parameters.
	 */
	this.getConnectParams = function(){
		return params;
	}

	this.db = {}

	/**
	 * Connect to redis server if not set client during initialize.
	 *
	 * @return {Boolean} true if success connect.
	 */
	this.connect = function(){
		if(params && params.client){
			client = params.client;
		}
		else{
			client = Redis.createClient(params.port, params.host, {parser: "hiredis"});
			if(params.password){
				client.auth(params.password);
			}

			return this.db = client
		}
	}
}

QueryRedis.prototype.querydb = function(params, cb){
	'use strict';
	var scan = 0, filter = params.filter, count = params.count, nomatch = [], db = this.connect(), countexec = 0, keys = [],
		redis2 = require("redis", {parser: "hiredis"}),
		client2 = redis2.createClient("redis://localhost", {parser: "hiredis"});
	client2.select(params.db2);

	if(!!params.db){
		this.db.select(params.db);
	}

	async.doWhilst(//scan
		function(next){
			db.send_command("scan", [scan, "MATCH", filter, "COUNT", count], function(err, result){
				if(err){
					console.error(err);
				}
				scan = +result[0];
				keys = keys.concat(result[1]);

				process.nextTick(squ)

				function squ(){
					var key = keys.pop()
					if(!key){
						if(!scan)
							cb()
						return
					}
					client2.exists(key, function(err, res){
						countexec++
						if(err)
							console.error(err)
						if(!res)
							console.log([key, res, countexec])

						process.nextTick(squ)
					})
				}

				setTimeout(next, 1000)
			})
		},
		function(){
			return scan > 0;
		},
		function(err){
			if(err){
				console.error(err);
			}
			cb()
		})

}

QueryRedis.prototype.queryset = function(params, cb){
	'use strict';
	var scan = 0, filter = params.filter, count = params.count, nomatch = [], db = this.connect(), countexec = 0, keys = [],
		redis2 = require("redis", {parser: "hiredis"}),
		client2 = redis2.createClient("redis://localhost", {parser: "hiredis"});
	client2.select(2);

	if(!!params.db){
		this.db.select(params.db);
	}

	async.doWhilst(//scan
		function(next){
			db.send_command("scan", [scan, "MATCH", filter, "COUNT", count], function(err, result){
				if(err){
					console.error(err);
				}
				scan = +result[0];
				keys = keys.concat(result[1]);

				squ()

				function squ(){
					var k = keys.pop()
					if(!k){
						if(!scan)
							process.exit(0)
						return
					}
					qu(k)
					function qu(key){
						/*						for(var j = 0, le = keys.length; j < le; j++){
						 */
						client2.sismember("dbkeys", key, function(err, res){
							countexec++
							if(err)
								console.error(err)
							if(!res){
								console.log([key, res, countexec])
							}
							process.nextTick(squ)
						})
					}
					/*						}
					 */					}


				setTimeout(next, 1000)
			})
		},
		function(){
			return scan > 0;
		},
		function(err){
			if(err){
				console.error(err);
			}
			cb()
		})


	function populateDbSet(cb){
		script = " \
    local res \
		res = redis.call('select',0) \
		res = redis.call('KEYS','*') \
		redis.call('select',2) \
		redis.call('DEL', 'dbkeys') \
		for idx = 1, #res, 1 do \
			redis.call('SADD', 'dbkeys', res[idx]) \
		end\
    return 1 \
";//
		/* client.eval(RandomPushScript,1,"mylist",10);*/
		this.db.eval(script, 0, function(err, res){
			console.log([err, res]);

		})
		/*this.db.script("load", script, function(err, result){
		 console.log([err, result]);
		 this.db.evalsha(result, 0, function(err, res){
		 console.log([err, res]);

		 })
		 });*/

	}

}

QueryRedis.prototype.queryfile = function(params, cb){
	'use strict';
	var scan = 0, filter = params.filter, count = params.count, nomatch = [], db = this.connect(),
		lineReader = require('line-reader-mod');


	Array.prototype.diff = function(a){
		return this.filter(function(i){
			return a.indexOf(i) < 0;
		});
	}
	if(!!params.db){
		this.db.select(params.db);
	}

	lineReader.open('dump.db', function(err, reader){
		if(err)
			throw err;
		async.whilst(//reader
			function(){
				return reader.hasNextLine()
			},
			function(nx){
				reader.nextLine(function(err, line){
					try{
						if(err)
							throw err;

						var items = line.split(new RegExp('(DEL|HMSET|SET|RPUSH|LPUSH|SADD|ZADD|HSET)', 'g'));

						var args = items.pop(), command = items.pop(), callArgs = [];
						switch(command){
							case 'DEL':
								return
								callArgs.push(args.chq());
								break;
							case 'SET':
							case 'SADD':
								callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?(.+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){
									return o.chq()
								});
								break;

							case 'RPUSH':
							case 'LPUSH':
								callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){
									return o.chq()
								});
								break;

							case 'ZADD':
								callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?\\s+"?(.+?)"?(\\s|$)', 'i')).slice(1, 4).map(function(o){
									return o.chq()
								});
								break;

							case 'HSET':
							case 'HMSET':
								var values = args.trim().split(new RegExp('id | parent | description | othername ', 'g'));

								callArgs.push(values.shift().chq());

								["id", "parent", "description", "othername"].forEach(function(o, i){
									callArgs.push(o.trim());
									callArgs.push(values[i].chq());
								})
								break

							default:
								console.error(command, args)
								callback('Error import data! Not supported type!')
								return
						}

						batch[command](callArgs)

					}finally{
						reader.close(function(err){
							if(err)
								throw err;
						})
					}
				})
				setTimeout(nx, 1000)
			},
			function(err){
				if(err)
					console.error(err);

				reader.close(function(err){
					if(err)
						throw err;
				})
				return cb(err);
			}
		)
	})
}

QueryRedis.prototype.queryredis = function(params, cb){
	'use strict';
	var split = require("split")
		;

	this.connect();

	async.waterfall([
		function(callback){
			if(!!params.db){
				this.getClient().select(params.db, callback);
			}else{
				callback(null, 'OK');
			}
		},
		function(status, callback){
			if(params.clear){
				/*				this.getClient().flushdb();
				 */			}
			callback();
		},
		function(_this){
			return function(callback){
				var lines = 0, batch = _this.getClient().batch();

				process.stdin.setEncoding('utf8');
				process.stdin.pipe(split())
					.on('data', function(line)
					{
						if(!line){
							return;
						}
						QueryRecursive(line);

						if(++lines > params.numcmd){
							batch.exec(function(){
								lines = 0;
							});
						}
					})
					.on('error', function(err){
						console.error(err);
					})
					.on('end', function(){
						batch.exec(callback);
					});

				String.prototype.rmq = function(){
					var str = this.substr(this.indexOf('"') + 1)
					return str.substr(0, str.lastIndexOf('"'))
				}
				String.prototype.chq = function(){
					var str = this.trim()
					if(str.indexOf('"') > -1){
						return str.rmq()
					}
					return str
				}

				function QueryRecursive(line){
					if(!line){
						return;
					}
					var items = line.split(new RegExp('(DEL|HMSET|SET|RPUSH|LPUSH|SADD|ZADD|HSET)', 'g'));

					var args = items.pop(),
						command = items.pop(),
						callArgs = [];

					switch(command){
						case 'DEL':
							return
							callArgs.push(args.chq());
							break;
						case 'SET':
						case 'SADD':
							callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?(.+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){
								return o.chq()
							});
							break;

						case 'RPUSH':
						case 'LPUSH':
							callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){
								return o.chq()
							});
							break;

						case 'ZADD':
							callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?\\s+"?(.+?)"?(\\s|$)', 'i')).slice(1, 4).map(function(o){
								return o.chq()
							});
							break;

						case 'HSET':
						case 'HMSET':
							var values = args.trim().split(new RegExp('id | parent | description | othername ', 'g'));

							callArgs.push(values.shift().chq());

							["id", "parent", "description", "othername"].forEach(function(o, i){
								callArgs.push(o.trim());
								callArgs.push(values[i].chq());
							})
							break

						default:
							console.error(command, args)
							callback('Error import data! Not supported type!')
							return
					}
					/*
					 callArgs.push(function(err, status){
					 if(err){
					 console.error(err);
					 }
					 });*/

					/*this.getClient()[command].apply(this.getClient(),callArgs);*/

					if(args.indexOf(callArgs[0]) == -1){
						console.error(callArgs)
					}

					var redis = _this.getClient()
					redis.hgetall(callArgs[0], function(err, result){
						if(err || !result || !Object.keys(result).length){
							console.error([err, callArgs])
						}
						result
					})

					/*batch[command](callArgs, function(err, status){
					 if(err){
					 console.error(err);
					 }
					 });*/
				}
			}
		}(this)
	],
		function(err){
			cb(err)
		})
}