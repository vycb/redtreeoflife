
/* global process, require, module, i */

var Redis = require('redis'),
	async = require('async'),
	_ = require('underscore-node');

/**
 * Redis dump class.
 *
 * @param {Object} params init params.
 * @constructor
 */
var RedisDump = module.exports = function(params){
	'use strict';

	var client;

	/**
	 * @return {String} version of library.
	 */
	this.getVersion = function(){
		return '0.2.1';
	};

	/**
	 * @return {Object} redis client.
	 */
	this.getClient = function(){
		return client || params.client;
	};

	this.setClient = function(cl){
		client = cl;
	};

	/**
	 * @return {Object} initialize parameters.
	 */
	this.getConnectParams = function(){
		return params;
	};

	/**
	 * Connect to redis server if not set client during initialize.
	 *
	 * @return {Boolean} true if success connect.
	 */
	this.connect = function(){
		if(params && params.client){
			client = params.client;
		}
		else{
			client = Redis.createClient(params.port, params.host, {parser: "hiredis"});
			if(params.password){
				client.auth(params.password);
			}
		}

		return this.db = client;
	}

	this.db = {};
}

/**
 * Import redis data.
 *
 * @param {Object} params
 * @param {function} cb callback
 */
RedisDump.prototype.import = function(params, cb){
	'use strict';
	var split = require("split"),
		report = [];

	this.getImportParams = function(){
		return params;
	};

	this.connect();

	async.waterfall([
		function(callback){
			if(_.isNumber(params.db)){
				this.getClient().select(params.db, callback);
			}else{
				callback(null, 'OK');
			}
		}.bind(this),
		function(status, callback){
			if(params.clear){
				console.log('clear db');
//				this.getClient().flushdb();
			}

			callback();
		}.bind(this),
		function(callback)
		{
			var lines =0, batch = this.db.batch()
			;

			process.stdin.setEncoding('utf8');
			process.stdin.pipe(split())
				.on('data', function(line)
				{
					if(!line){
						return;
					}
					AddRecursive(line);

					if(++lines > params.numcmd){
						batch.exec(function(){
							lines = 0;
						});
					}
				})
				.on('error', function(err){
					console.error(err);
				})
				.on('end', function(){
					batch.exec(callback);
				});

			String.prototype.rmq = function(){
				var str = this.substr(this.indexOf('"')+1)
				return str.substr(0,str.lastIndexOf('"'))
			}
			String.prototype.chq = function(){
				var str = this.trim()
				if(str.indexOf('"') >-1){
					 return str.rmq()
				}
				return str
			}

			var AddRecursive = function(line){
				if(!line){
					return;
				}
				var items = line.split(new RegExp('(DEL|HMSET|SET|RPUSH|LPUSH|SADD|ZADD|HSET)', 'g'));

				var args = items.pop(),
					command = items.pop(),
					callArgs = [];

				switch(command){
					case 'DEL':
						callArgs.push(args.chq());
						break;
					case 'SET':
					case 'SADD':
						callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?(.+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){return o.chq()});
						break;

					case 'RPUSH':
					case 'LPUSH':
						callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){return o.chq()});
						break;

					case 'ZADD':
						callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?\\s+"?(.+?)"?(\\s|$)', 'i')).slice(1, 4).map(function(o){return o.chq()});
						break;

					case 'HSET':
					case 'HMSET':
						var props = ["id","parent","description","othername"], sorti = [], regexs="", values;
						for(var i of props){
							sorti.push({o:i,id:args.indexOf(i)})
						}
						sorti = sorti.sort(function(a, b){
							if(a.id<b.id)
								return-1;
							if(a.id>b.id)
								return 1;
							return 0;
						})
						sorti.forEach(function(a, i){
							regexs += " "+a.o+(i+1<sorti.length?" |":"")//' id | parent | description | othername '
						})

						values = args.trim().split(new RegExp(regexs, 'g'))

						if(args.indexOf("Hydromyini:50746")>-1){
							values
						}

						callArgs.push(values.shift().chq());

						if(args.indexOf(callArgs[0]) ==-1){
							callArgs;
						}

						sorti.forEach(function(a, i){
							callArgs.push(a.o);
							callArgs.push(values[i].chq());
						})
						break;

					default:
						console.error(command, args);
						callback('Error import data! Not supported type!');
						return;
				}
/*
				callArgs.push(function(err, status){
					if(err){
						console.error(err);
					}
				});*/

				/*this.getClient()[command].apply(this.getClient(),callArgs);*/
				this.db[command](callArgs,function(err, status){
					if(err){
						console.error(err);
					}
				});



				/*batch[command](callArgs, function(err, status){
					if(err){
						console.error(err);
					}
				});*/
			}.bind(this);


		}.bind(this)

	],
		function(err){
			cb(err, report);
		});
};