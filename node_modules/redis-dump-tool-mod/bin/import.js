
/* global process, require */

var Redis = require('redis'),
	async = require('async'),
	_ = require('underscore-node');

/**
 * Redis dump class.
 *
 * @param {Object} params init params.
 * @constructor
 */
var RedisDump = module.exports = function(params){
	'use strict';

	var client;

	/**
	 * @return {String} version of library.
	 */
	this.getVersion = function(){
		return '0.2.1';
	};

	/**
	 * @return {Object} redis client.
	 */
	this.getClient = function(){
		return client || params.client;
	};

	this.setClient = function(cl){
		client = cl;
	};

	/**
	 * @return {Object} initialize parameters.
	 */
	this.getConnectParams = function(){
		return params;
	};

	/**
	 * Connect to redis server if not set client during initialize.
	 *
	 * @return {Boolean} true if success connect.
	 */
	this.connect = function(){
		if(params && params.client){
			client = params.client;
		}
		else{
			client = Redis.createClient(params.port, params.host, {parser: "hiredis"});
			if(params.password){
				client.auth(params.password);
			}
		}

		return !client;
	};
};

/**
 * Read key callback by type.
 */
var GetForTypeCallback = function(key, data, callback){
	'use strict';

	/**
	 * Read scores by values.
	 *
	 * @param {Array} values
	 * @param {Function} callback
	 */
	var ReadScores = function(values, callback){
		var result = [];

		/**
		 * Get scores recursive.
		 */
		var GetRecursive = function(){
			if(!values.length){
				callback(null, result);
				return;
			}

			var value = values.pop();

			this.getClient().zscore(key, value, function(err, score){
				if(err){
					callback(err);
					return;
				}

				result.push(score);
				GetRecursive();
			});
		}.bind(this);

		GetRecursive();
	}.bind(this);

	/**
	 * Read key.
	 *
	 * @param {String} key
	 * @param {String} type
	 * @param {Function} rkCallback
	 */
	var ReadKey = function(key, type, rkCallback){
		var params = [key],
			command = {
				set: 'smembers',
				zset: 'zrange',
				list: 'lrange',
				hash: 'hgetall'
			}[ type ] || 'get';

		if(command.indexOf('range') !== -1){
			params.push(0);
			params.push(-1);
		}

		params.push(function(err, values){
			if(err){
				rkCallback(err);
				return;
			}

			switch(type){
				case 'zset':
					ReadScores(_.clone(values).reverse(), function(err, scores){
						rkCallback(null, _.zip(scores, values));
					});
					break;

				default:
					rkCallback(null, values);
					break;
			}
		});

		this.getClient()[ command ].apply(this.getClient(), params);
	}.bind(this);


	switch(this.getExportParams().type){
		//	Export as redis type.
		case 'redis':
			return function(err, type){
				var type2PrintSetCommand = {
					string: 'SET',
					set: 'SADD',
					zset: 'ZADD',
					list: 'RPUSH',
					hash: 'HSET'
				};

				if(!data){
					data = '';
				}

				ReadKey(key, type, function(err, value){
					if(err){
						callback(err);
						return;
					}

					var command = type2PrintSetCommand[ type ];

					key = key.trim();

					switch(type){
						case 'set':
							_.each(value, function(item){
								data += command + ' "' + key + '" "' + item + "\"\n";
							});
							break;

						case 'zset':
							_.each(value, function(item){
								data += command + ' "' + key + '" ' + item[0] + ' "' + item[1] + "\"\n";
							});
							break;

						case 'hash':
							_.each(_.pairs(value), function(item){
								data += command + ' "' + key + '" "' + item[0] + '" "' + item[1] + "\"\n";
							});
							break;

						default:
							data += command + ' "' + key + '" "' + value + "\"\n";
							break;
					}

					callback(null, data);
				});
			};

			//	Export as json type.
		case 'json':
			return function(err, type){
				if(!data){
					data = {};
				}

				ReadKey(key, type, function(err, value){
					if(err){
						callback(err);
						return;
					}

					switch(type){
						case 'zset':
							var withoutScores = [];
							_.each(value, function(item){
								withoutScores.push(item[1]);
							});
							value = withoutScores;
							break;
					}

					data[ key.trim() ] = value;

					callback(null, data);
				});
			};
	}
};

/**
 * Make redis dump.
 *
 * @param {Object} params
 */
RedisDump.prototype.export = function(params){
	'use strict';

	/**
	 * @return {Object} export params
	 */
	this.getExportParams = function(){
		return params;
	};

	async.waterfall([
		/**
		 * Get keys.
		 *
		 * @param callback
		 */
		function(callback){
			this.getClient().keys('*', callback);
		}.bind(this),
		/**
		 * Read keys.
		 *
		 * @param keys
		 * @param callback
		 */
		function(keys, callback){
			var exportData;

			/**
			 * Read keys recursive.
			 */
			var ReadKeysRecursive = function(err, data){
				if(err){
					callback(err);
					return;
				}

				if(data){
					exportData = data;
				}

				if(!keys.length){
					callback(null, exportData);
					return;
				}

				var key = keys.pop();

				this.getClient().type(key, GetForTypeCallback.call(this, key, exportData, ReadKeysRecursive));
			}.bind(this);

			ReadKeysRecursive();
		}.bind(this)
	],
		function(err, data){
			if(!_.isFunction(params.callback)){
				params.callback = function(){
				};
			}

			params.callback(err, data);
		});
};

/**
 * Import redis data.
 *
 * @param {Object} params
 * @param {function} cb callback
 */
RedisDump.prototype.import = function(params, cb){
	'use strict';
	var split = require("split"),
		report = [];

	this.getImportParams = function(){
		return params;
	};

	this.connect();

	async.waterfall([
		function(callback){
			if(_.isNumber(params.db)){
				this.getClient().select(params.db, callback);
			}else{
				callback(null, 'OK');
			}
		}.bind(this),
		function(status, callback){
			if(params.clear){
				console.log('clear db');
//				this.getClient().flushdb();
			}

			callback();
		}.bind(this),
		function(callback)
		{
			var lines =0, batch = this.getClient().batch();


			process.stdin.setEncoding('utf8');
			process.stdin.pipe(split())
				.on('data', function(line)
				{
					if(!line){
						return;
					}
					AddRecursive(line);

					if(++lines > params.numcmd){
						batch.exec(function(){
							lines = 0;
						});
					}
				})
				.on('error', function(err){
					console.error(err);
				})
				.on('end', function(){
					batch.exec(callback);
				});

			String.prototype.noq = function(){
				var str = this.substr(this.indexOf('"')+1)
				return str.substr(0,str.lastIndexOf('"'))
			}
			String.prototype.chq = function(){
				var str = this.trim()
				if(str.indexOf('"') >-1){
					 return str.noq()
				}
				return str
			}

			var AddRecursive = function(line){
				if(!line){
					return;
				}
				var items = line.split(new RegExp('(DEL|HMSET|SET|RPUSH|LPUSH|SADD|ZADD|HSET)', 'g'));

				var args = items.pop(),
					command = items.pop(),
					callArgs = [];

				switch(command){
					case 'DEL':
						callArgs.push(args.noq());
						break;
					case 'SET':
					case 'SADD':
						callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?(.+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){return o.noq()});
						break;

					case 'RPUSH':
					case 'LPUSH':
						callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?(?:\\s|$)', 'i')).slice(1, 3).map(function(o){return o.noq()});
						break;

					case 'ZADD':
						callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?\\s+"?(.+?)"?(\\s|$)', 'i')).slice(1, 4).map(function(o){return o.noq()});
						break;

					case 'HSET':
					case 'HMSET':
						var values = args.trim().split(new RegExp('id | parent | description | othername ', 'g'));

						callArgs.push(values.shift().chq());

						["id","parent","description","othername"].forEach(function(o, i){
							callArgs.push(o.trim());
							callArgs.push(values[i].chq());
						});
						break;

					default:
						console.error(command, args);
						callback('Error import data! Not supported type!');
						return;
				}

				callArgs.push(function(err, status){
					if(err){
						console.error(err);
					}
				});

//				this.getClient()[command].apply(this.getClient(),callArgs);
				batch[command](callArgs);
			}.bind(this);


		}.bind(this)

	],
		function(err){
			cb(err, report);
		});
};